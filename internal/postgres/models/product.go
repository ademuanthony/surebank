// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Product is an object representing the database table.
type Product struct {
	ID           string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	BrandID      null.String `boil:"brand_id" json:"brand_id,omitempty" toml:"brand_id" yaml:"brand_id,omitempty"`
	CategoryID   string      `boil:"category_id" json:"category_id" toml:"category_id" yaml:"category_id"`
	Name         string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Description  string      `boil:"description" json:"description" toml:"description" yaml:"description"`
	Sku          string      `boil:"sku" json:"sku" toml:"sku" yaml:"sku"`
	Barcode      string      `boil:"barcode" json:"barcode" toml:"barcode" yaml:"barcode"`
	Price        float64     `boil:"price" json:"price" toml:"price" yaml:"price"`
	ReorderLevel int         `boil:"reorder_level" json:"reorder_level" toml:"reorder_level" yaml:"reorder_level"`
	Image        null.String `boil:"image" json:"image,omitempty" toml:"image" yaml:"image,omitempty"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	ArchivedAt   null.Time   `boil:"archived_at" json:"archived_at,omitempty" toml:"archived_at" yaml:"archived_at,omitempty"`
	CreatedByID  string      `boil:"created_by_id" json:"created_by_id" toml:"created_by_id" yaml:"created_by_id"`
	UpdatedByID  string      `boil:"updated_by_id" json:"updated_by_id" toml:"updated_by_id" yaml:"updated_by_id"`
	ArchivedByID null.String `boil:"archived_by_id" json:"archived_by_id,omitempty" toml:"archived_by_id" yaml:"archived_by_id,omitempty"`
	StockBalance int         `boil:"stock_balance" json:"stock_balance" toml:"stock_balance" yaml:"stock_balance"`
	CostPrice    float64     `boil:"cost_price" json:"cost_price" toml:"cost_price" yaml:"cost_price"`

	R *productR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L productL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ProductColumns = struct {
	ID           string
	BrandID      string
	CategoryID   string
	Name         string
	Description  string
	Sku          string
	Barcode      string
	Price        string
	ReorderLevel string
	Image        string
	CreatedAt    string
	UpdatedAt    string
	ArchivedAt   string
	CreatedByID  string
	UpdatedByID  string
	ArchivedByID string
	StockBalance string
	CostPrice    string
}{
	ID:           "id",
	BrandID:      "brand_id",
	CategoryID:   "category_id",
	Name:         "name",
	Description:  "description",
	Sku:          "sku",
	Barcode:      "barcode",
	Price:        "price",
	ReorderLevel: "reorder_level",
	Image:        "image",
	CreatedAt:    "created_at",
	UpdatedAt:    "updated_at",
	ArchivedAt:   "archived_at",
	CreatedByID:  "created_by_id",
	UpdatedByID:  "updated_by_id",
	ArchivedByID: "archived_by_id",
	StockBalance: "stock_balance",
	CostPrice:    "cost_price",
}

var ProductTableColumns = struct {
	ID           string
	BrandID      string
	CategoryID   string
	Name         string
	Description  string
	Sku          string
	Barcode      string
	Price        string
	ReorderLevel string
	Image        string
	CreatedAt    string
	UpdatedAt    string
	ArchivedAt   string
	CreatedByID  string
	UpdatedByID  string
	ArchivedByID string
	StockBalance string
	CostPrice    string
}{
	ID:           "product.id",
	BrandID:      "product.brand_id",
	CategoryID:   "product.category_id",
	Name:         "product.name",
	Description:  "product.description",
	Sku:          "product.sku",
	Barcode:      "product.barcode",
	Price:        "product.price",
	ReorderLevel: "product.reorder_level",
	Image:        "product.image",
	CreatedAt:    "product.created_at",
	UpdatedAt:    "product.updated_at",
	ArchivedAt:   "product.archived_at",
	CreatedByID:  "product.created_by_id",
	UpdatedByID:  "product.updated_by_id",
	ArchivedByID: "product.archived_by_id",
	StockBalance: "product.stock_balance",
	CostPrice:    "product.cost_price",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var ProductWhere = struct {
	ID           whereHelperstring
	BrandID      whereHelpernull_String
	CategoryID   whereHelperstring
	Name         whereHelperstring
	Description  whereHelperstring
	Sku          whereHelperstring
	Barcode      whereHelperstring
	Price        whereHelperfloat64
	ReorderLevel whereHelperint
	Image        whereHelpernull_String
	CreatedAt    whereHelpertime_Time
	UpdatedAt    whereHelpertime_Time
	ArchivedAt   whereHelpernull_Time
	CreatedByID  whereHelperstring
	UpdatedByID  whereHelperstring
	ArchivedByID whereHelpernull_String
	StockBalance whereHelperint
	CostPrice    whereHelperfloat64
}{
	ID:           whereHelperstring{field: "\"product\".\"id\""},
	BrandID:      whereHelpernull_String{field: "\"product\".\"brand_id\""},
	CategoryID:   whereHelperstring{field: "\"product\".\"category_id\""},
	Name:         whereHelperstring{field: "\"product\".\"name\""},
	Description:  whereHelperstring{field: "\"product\".\"description\""},
	Sku:          whereHelperstring{field: "\"product\".\"sku\""},
	Barcode:      whereHelperstring{field: "\"product\".\"barcode\""},
	Price:        whereHelperfloat64{field: "\"product\".\"price\""},
	ReorderLevel: whereHelperint{field: "\"product\".\"reorder_level\""},
	Image:        whereHelpernull_String{field: "\"product\".\"image\""},
	CreatedAt:    whereHelpertime_Time{field: "\"product\".\"created_at\""},
	UpdatedAt:    whereHelpertime_Time{field: "\"product\".\"updated_at\""},
	ArchivedAt:   whereHelpernull_Time{field: "\"product\".\"archived_at\""},
	CreatedByID:  whereHelperstring{field: "\"product\".\"created_by_id\""},
	UpdatedByID:  whereHelperstring{field: "\"product\".\"updated_by_id\""},
	ArchivedByID: whereHelpernull_String{field: "\"product\".\"archived_by_id\""},
	StockBalance: whereHelperint{field: "\"product\".\"stock_balance\""},
	CostPrice:    whereHelperfloat64{field: "\"product\".\"cost_price\""},
}

// ProductRels is where relationship names are stored.
var ProductRels = struct {
	ArchivedBy        string
	Brand             string
	Category          string
	CreatedBy         string
	UpdatedBy         string
	Inventories       string
	ProductCategories string
	SaleItems         string
}{
	ArchivedBy:        "ArchivedBy",
	Brand:             "Brand",
	Category:          "Category",
	CreatedBy:         "CreatedBy",
	UpdatedBy:         "UpdatedBy",
	Inventories:       "Inventories",
	ProductCategories: "ProductCategories",
	SaleItems:         "SaleItems",
}

// productR is where relationships are stored.
type productR struct {
	ArchivedBy        *User                `boil:"ArchivedBy" json:"ArchivedBy" toml:"ArchivedBy" yaml:"ArchivedBy"`
	Brand             *Brand               `boil:"Brand" json:"Brand" toml:"Brand" yaml:"Brand"`
	Category          *Category            `boil:"Category" json:"Category" toml:"Category" yaml:"Category"`
	CreatedBy         *User                `boil:"CreatedBy" json:"CreatedBy" toml:"CreatedBy" yaml:"CreatedBy"`
	UpdatedBy         *User                `boil:"UpdatedBy" json:"UpdatedBy" toml:"UpdatedBy" yaml:"UpdatedBy"`
	Inventories       InventorySlice       `boil:"Inventories" json:"Inventories" toml:"Inventories" yaml:"Inventories"`
	ProductCategories ProductCategorySlice `boil:"ProductCategories" json:"ProductCategories" toml:"ProductCategories" yaml:"ProductCategories"`
	SaleItems         SaleItemSlice        `boil:"SaleItems" json:"SaleItems" toml:"SaleItems" yaml:"SaleItems"`
}

// NewStruct creates a new relationship struct
func (*productR) NewStruct() *productR {
	return &productR{}
}

// productL is where Load methods for each relationship are stored.
type productL struct{}

var (
	productAllColumns            = []string{"id", "brand_id", "category_id", "name", "description", "sku", "barcode", "price", "reorder_level", "image", "created_at", "updated_at", "archived_at", "created_by_id", "updated_by_id", "archived_by_id", "stock_balance", "cost_price"}
	productColumnsWithoutDefault = []string{"id", "brand_id", "category_id", "name", "description", "sku", "barcode", "price", "reorder_level", "image", "created_at", "updated_at", "archived_at", "created_by_id", "updated_by_id", "archived_by_id", "stock_balance"}
	productColumnsWithDefault    = []string{"cost_price"}
	productPrimaryKeyColumns     = []string{"id"}
)

type (
	// ProductSlice is an alias for a slice of pointers to Product.
	// This should almost always be used instead of []Product.
	ProductSlice []*Product

	productQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	productType                 = reflect.TypeOf(&Product{})
	productMapping              = queries.MakeStructMapping(productType)
	productPrimaryKeyMapping, _ = queries.BindMapping(productType, productMapping, productPrimaryKeyColumns)
	productInsertCacheMut       sync.RWMutex
	productInsertCache          = make(map[string]insertCache)
	productUpdateCacheMut       sync.RWMutex
	productUpdateCache          = make(map[string]updateCache)
	productUpsertCacheMut       sync.RWMutex
	productUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single product record from the query.
func (q productQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Product, error) {
	o := &Product{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for product")
	}

	return o, nil
}

// All returns all Product records from the query.
func (q productQuery) All(ctx context.Context, exec boil.ContextExecutor) (ProductSlice, error) {
	var o []*Product

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Product slice")
	}

	return o, nil
}

// Count returns the count of all Product records in the query.
func (q productQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count product rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q productQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if product exists")
	}

	return count > 0, nil
}

// ArchivedBy pointed to by the foreign key.
func (o *Product) ArchivedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ArchivedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Brand pointed to by the foreign key.
func (o *Product) Brand(mods ...qm.QueryMod) brandQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BrandID),
	}

	queryMods = append(queryMods, mods...)

	query := Brands(queryMods...)
	queries.SetFrom(query.Query, "\"brand\"")

	return query
}

// Category pointed to by the foreign key.
func (o *Product) Category(mods ...qm.QueryMod) categoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CategoryID),
	}

	queryMods = append(queryMods, mods...)

	query := Categories(queryMods...)
	queries.SetFrom(query.Query, "\"category\"")

	return query
}

// CreatedBy pointed to by the foreign key.
func (o *Product) CreatedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// UpdatedBy pointed to by the foreign key.
func (o *Product) UpdatedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UpdatedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Inventories retrieves all the inventory's Inventories with an executor.
func (o *Product) Inventories(mods ...qm.QueryMod) inventoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"inventory\".\"product_id\"=?", o.ID),
	)

	query := Inventories(queryMods...)
	queries.SetFrom(query.Query, "\"inventory\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"inventory\".*"})
	}

	return query
}

// ProductCategories retrieves all the product_category's ProductCategories with an executor.
func (o *Product) ProductCategories(mods ...qm.QueryMod) productCategoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"product_category\".\"product_id\"=?", o.ID),
	)

	query := ProductCategories(queryMods...)
	queries.SetFrom(query.Query, "\"product_category\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"product_category\".*"})
	}

	return query
}

// SaleItems retrieves all the sale_item's SaleItems with an executor.
func (o *Product) SaleItems(mods ...qm.QueryMod) saleItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"sale_item\".\"product_id\"=?", o.ID),
	)

	query := SaleItems(queryMods...)
	queries.SetFrom(query.Query, "\"sale_item\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"sale_item\".*"})
	}

	return query
}

// LoadArchivedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productL) LoadArchivedBy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		if !queries.IsNil(object.ArchivedByID) {
			args = append(args, object.ArchivedByID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ArchivedByID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ArchivedByID) {
				args = append(args, obj.ArchivedByID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ArchivedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ArchivedByProducts = append(foreign.R.ArchivedByProducts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ArchivedByID, foreign.ID) {
				local.R.ArchivedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ArchivedByProducts = append(foreign.R.ArchivedByProducts, local)
				break
			}
		}
	}

	return nil
}

// LoadBrand allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productL) LoadBrand(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		if !queries.IsNil(object.BrandID) {
			args = append(args, object.BrandID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BrandID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BrandID) {
				args = append(args, obj.BrandID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`brand`),
		qm.WhereIn(`brand.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Brand")
	}

	var resultSlice []*Brand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Brand")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for brand")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for brand")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Brand = foreign
		if foreign.R == nil {
			foreign.R = &brandR{}
		}
		foreign.R.Products = append(foreign.R.Products, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BrandID, foreign.ID) {
				local.R.Brand = foreign
				if foreign.R == nil {
					foreign.R = &brandR{}
				}
				foreign.R.Products = append(foreign.R.Products, local)
				break
			}
		}
	}

	return nil
}

// LoadCategory allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productL) LoadCategory(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.CategoryID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.CategoryID {
					continue Outer
				}
			}

			args = append(args, obj.CategoryID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`category`),
		qm.WhereIn(`category.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Category")
	}

	var resultSlice []*Category
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Category")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for category")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Category = foreign
		if foreign.R == nil {
			foreign.R = &categoryR{}
		}
		foreign.R.Products = append(foreign.R.Products, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CategoryID == foreign.ID {
				local.R.Category = foreign
				if foreign.R == nil {
					foreign.R = &categoryR{}
				}
				foreign.R.Products = append(foreign.R.Products, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productL) LoadCreatedBy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.CreatedByID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.CreatedByID {
					continue Outer
				}
			}

			args = append(args, obj.CreatedByID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByProducts = append(foreign.R.CreatedByProducts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CreatedByID == foreign.ID {
				local.R.CreatedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByProducts = append(foreign.R.CreatedByProducts, local)
				break
			}
		}
	}

	return nil
}

// LoadUpdatedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productL) LoadUpdatedBy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.UpdatedByID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.UpdatedByID {
					continue Outer
				}
			}

			args = append(args, obj.UpdatedByID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UpdatedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.UpdatedByProducts = append(foreign.R.UpdatedByProducts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UpdatedByID == foreign.ID {
				local.R.UpdatedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.UpdatedByProducts = append(foreign.R.UpdatedByProducts, local)
				break
			}
		}
	}

	return nil
}

// LoadInventories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (productL) LoadInventories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`inventory`),
		qm.WhereIn(`inventory.product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load inventory")
	}

	var resultSlice []*Inventory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice inventory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on inventory")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for inventory")
	}

	if singular {
		object.R.Inventories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &inventoryR{}
			}
			foreign.R.Product = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ProductID {
				local.R.Inventories = append(local.R.Inventories, foreign)
				if foreign.R == nil {
					foreign.R = &inventoryR{}
				}
				foreign.R.Product = local
				break
			}
		}
	}

	return nil
}

// LoadProductCategories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (productL) LoadProductCategories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product_category`),
		qm.WhereIn(`product_category.product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load product_category")
	}

	var resultSlice []*ProductCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice product_category")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on product_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_category")
	}

	if singular {
		object.R.ProductCategories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productCategoryR{}
			}
			foreign.R.Product = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ProductID {
				local.R.ProductCategories = append(local.R.ProductCategories, foreign)
				if foreign.R == nil {
					foreign.R = &productCategoryR{}
				}
				foreign.R.Product = local
				break
			}
		}
	}

	return nil
}

// LoadSaleItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (productL) LoadSaleItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProduct interface{}, mods queries.Applicator) error {
	var slice []*Product
	var object *Product

	if singular {
		object = maybeProduct.(*Product)
	} else {
		slice = *maybeProduct.(*[]*Product)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sale_item`),
		qm.WhereIn(`sale_item.product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sale_item")
	}

	var resultSlice []*SaleItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sale_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sale_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sale_item")
	}

	if singular {
		object.R.SaleItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &saleItemR{}
			}
			foreign.R.Product = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ProductID {
				local.R.SaleItems = append(local.R.SaleItems, foreign)
				if foreign.R == nil {
					foreign.R = &saleItemR{}
				}
				foreign.R.Product = local
				break
			}
		}
	}

	return nil
}

// SetArchivedBy of the product to the related item.
// Sets o.R.ArchivedBy to related.
// Adds o to related.R.ArchivedByProducts.
func (o *Product) SetArchivedBy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"archived_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ArchivedByID, related.ID)
	if o.R == nil {
		o.R = &productR{
			ArchivedBy: related,
		}
	} else {
		o.R.ArchivedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			ArchivedByProducts: ProductSlice{o},
		}
	} else {
		related.R.ArchivedByProducts = append(related.R.ArchivedByProducts, o)
	}

	return nil
}

// RemoveArchivedBy relationship.
// Sets o.R.ArchivedBy to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Product) RemoveArchivedBy(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.ArchivedByID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("archived_by_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ArchivedBy = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ArchivedByProducts {
		if queries.Equal(o.ArchivedByID, ri.ArchivedByID) {
			continue
		}

		ln := len(related.R.ArchivedByProducts)
		if ln > 1 && i < ln-1 {
			related.R.ArchivedByProducts[i] = related.R.ArchivedByProducts[ln-1]
		}
		related.R.ArchivedByProducts = related.R.ArchivedByProducts[:ln-1]
		break
	}
	return nil
}

// SetBrand of the product to the related item.
// Sets o.R.Brand to related.
// Adds o to related.R.Products.
func (o *Product) SetBrand(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Brand) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"brand_id"}),
		strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BrandID, related.ID)
	if o.R == nil {
		o.R = &productR{
			Brand: related,
		}
	} else {
		o.R.Brand = related
	}

	if related.R == nil {
		related.R = &brandR{
			Products: ProductSlice{o},
		}
	} else {
		related.R.Products = append(related.R.Products, o)
	}

	return nil
}

// RemoveBrand relationship.
// Sets o.R.Brand to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Product) RemoveBrand(ctx context.Context, exec boil.ContextExecutor, related *Brand) error {
	var err error

	queries.SetScanner(&o.BrandID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("brand_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Brand = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Products {
		if queries.Equal(o.BrandID, ri.BrandID) {
			continue
		}

		ln := len(related.R.Products)
		if ln > 1 && i < ln-1 {
			related.R.Products[i] = related.R.Products[ln-1]
		}
		related.R.Products = related.R.Products[:ln-1]
		break
	}
	return nil
}

// SetCategory of the product to the related item.
// Sets o.R.Category to related.
// Adds o to related.R.Products.
func (o *Product) SetCategory(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Category) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"category_id"}),
		strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CategoryID = related.ID
	if o.R == nil {
		o.R = &productR{
			Category: related,
		}
	} else {
		o.R.Category = related
	}

	if related.R == nil {
		related.R = &categoryR{
			Products: ProductSlice{o},
		}
	} else {
		related.R.Products = append(related.R.Products, o)
	}

	return nil
}

// SetCreatedBy of the product to the related item.
// Sets o.R.CreatedBy to related.
// Adds o to related.R.CreatedByProducts.
func (o *Product) SetCreatedBy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CreatedByID = related.ID
	if o.R == nil {
		o.R = &productR{
			CreatedBy: related,
		}
	} else {
		o.R.CreatedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByProducts: ProductSlice{o},
		}
	} else {
		related.R.CreatedByProducts = append(related.R.CreatedByProducts, o)
	}

	return nil
}

// SetUpdatedBy of the product to the related item.
// Sets o.R.UpdatedBy to related.
// Adds o to related.R.UpdatedByProducts.
func (o *Product) SetUpdatedBy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"updated_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UpdatedByID = related.ID
	if o.R == nil {
		o.R = &productR{
			UpdatedBy: related,
		}
	} else {
		o.R.UpdatedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			UpdatedByProducts: ProductSlice{o},
		}
	} else {
		related.R.UpdatedByProducts = append(related.R.UpdatedByProducts, o)
	}

	return nil
}

// AddInventories adds the given related objects to the existing relationships
// of the product, optionally inserting them as new records.
// Appends related to o.R.Inventories.
// Sets related.R.Product appropriately.
func (o *Product) AddInventories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Inventory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProductID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"inventory\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"product_id"}),
				strmangle.WhereClause("\"", "\"", 2, inventoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProductID = o.ID
		}
	}

	if o.R == nil {
		o.R = &productR{
			Inventories: related,
		}
	} else {
		o.R.Inventories = append(o.R.Inventories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &inventoryR{
				Product: o,
			}
		} else {
			rel.R.Product = o
		}
	}
	return nil
}

// AddProductCategories adds the given related objects to the existing relationships
// of the product, optionally inserting them as new records.
// Appends related to o.R.ProductCategories.
// Sets related.R.Product appropriately.
func (o *Product) AddProductCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProductCategory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProductID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"product_category\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"product_id"}),
				strmangle.WhereClause("\"", "\"", 2, productCategoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProductID = o.ID
		}
	}

	if o.R == nil {
		o.R = &productR{
			ProductCategories: related,
		}
	} else {
		o.R.ProductCategories = append(o.R.ProductCategories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productCategoryR{
				Product: o,
			}
		} else {
			rel.R.Product = o
		}
	}
	return nil
}

// AddSaleItems adds the given related objects to the existing relationships
// of the product, optionally inserting them as new records.
// Appends related to o.R.SaleItems.
// Sets related.R.Product appropriately.
func (o *Product) AddSaleItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SaleItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProductID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"sale_item\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"product_id"}),
				strmangle.WhereClause("\"", "\"", 2, saleItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProductID = o.ID
		}
	}

	if o.R == nil {
		o.R = &productR{
			SaleItems: related,
		}
	} else {
		o.R.SaleItems = append(o.R.SaleItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &saleItemR{
				Product: o,
			}
		} else {
			rel.R.Product = o
		}
	}
	return nil
}

// Products retrieves all the records using an executor.
func Products(mods ...qm.QueryMod) productQuery {
	mods = append(mods, qm.From("\"product\""))
	return productQuery{NewQuery(mods...)}
}

// FindProduct retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindProduct(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Product, error) {
	productObj := &Product{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"product\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, productObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from product")
	}

	return productObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Product) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no product provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(productColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	productInsertCacheMut.RLock()
	cache, cached := productInsertCache[key]
	productInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			productAllColumns,
			productColumnsWithDefault,
			productColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(productType, productMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(productType, productMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"product\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"product\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into product")
	}

	if !cached {
		productInsertCacheMut.Lock()
		productInsertCache[key] = cache
		productInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Product.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Product) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	productUpdateCacheMut.RLock()
	cache, cached := productUpdateCache[key]
	productUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			productAllColumns,
			productPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update product, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"product\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, productPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(productType, productMapping, append(wl, productPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update product row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for product")
	}

	if !cached {
		productUpdateCacheMut.Lock()
		productUpdateCache[key] = cache
		productUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q productQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for product")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for product")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ProductSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"product\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, productPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in product slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all product")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Product) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no product provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(productColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	productUpsertCacheMut.RLock()
	cache, cached := productUpsertCache[key]
	productUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			productAllColumns,
			productColumnsWithDefault,
			productColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			productAllColumns,
			productPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert product, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(productPrimaryKeyColumns))
			copy(conflict, productPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"product\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(productType, productMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(productType, productMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert product")
	}

	if !cached {
		productUpsertCacheMut.Lock()
		productUpsertCache[key] = cache
		productUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Product record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Product) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Product provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), productPrimaryKeyMapping)
	sql := "DELETE FROM \"product\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from product")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for product")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q productQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no productQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from product")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for product")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ProductSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"product\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, productPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from product slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for product")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Product) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindProduct(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ProductSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ProductSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"product\".* FROM \"product\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, productPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ProductSlice")
	}

	*o = slice

	return nil
}

// ProductExists checks if the Product row exists.
func ProductExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"product\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if product exists")
	}

	return exists, nil
}
